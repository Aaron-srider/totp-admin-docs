# Ldap数据同步

本模块主要是为了同步Ldap的用户和组数据到本系统，目前只做成手动同步的形式。

## 同步机制

只要是数据同步，就涉及以下几个问题：

1. 数据生产方的数据存储结构是怎样的（数据消费方的数据结构必须根据数据生产方来确定）。
2. 数据消费方一次从数据生产方拉取多少数据。
3. 数据消费方拉取到数据后，如何定义本系统数据和生产方数据之间的差异，也就是需要同步的是哪部分数据，以及具体如何更新数据。

下面根据本系统的实际情况依次阐述上述的同步问题，在阐述的过程中，以“消费方”或“数据消费方”指代“本系统”，“生产方”或“数据生产方”指代Ldap。

**数据存储结构**

因为在数据同步的语境中，总是有一方被动提供数据，有一方主动请求数据，所以数据消费方的数据存储结构总是依赖于数据生产方的。经调研，生产方主要有两个实体：用户和组。用户通常有以下字段：sAMAccountName，cn，mail，ou（organizationalUnit），userpassword等，而组的字段就偏少，只有ou。

根据生产方的数据结构，在本系统中构建两个对应的数据接收实体类和两个数据存储实体类（数据库对象PO）。数据接收实体类字段与数据生产方的数据结构完全一致，而数据存储实体类则是根据本系统的情况定制的实体类，虽然字段可能与数据接收实体类不一致，但大体上都是一样的。那为何需要设置两种实体类呢？只有数据接收实体类或数据存储实体类是否可行呢？答案是可行的，但是这么做会带来一些不便。比如，如果数据生产方的数据结构改变了，那么数据消费方的数据存储结构也得改变，但是改变数据的存储结构是很困难的一件事情，用数据库存储数据为例，修改数据的存储结构就意味着修改数据库的表结构、修改代码中的数据库映射实体类、修改代码中涉及到表字段的逻辑部分，这样的修改容易产生Bug，且这些Bug难以排查干净。因此，为了让消费方的数据存储结构保持相对稳定的状态，就需要加一层作为缓冲，这一层就是数据接收实体类，这部分实体类基本不参与消费方的业务逻辑，只是作为数据生产方的映射实体，每当数据生产方的数据结构改变了，对数据接收实体的修改是不会对本系统产生关键性的改动的。虽然增加了一层，但本系统的数据存储实体还是需要改变，即使如此，大部分的改变已经被数据接收实体类层吸收了，存储结构只需要做微调即可。

**一次拉取的数据量**

由于拉取到的数据在持久化之前都需要在内存中驻留一段时间，因此需要考虑数据量是否会超出进程的内存空间大小。对于Ldap来说，用户数据的体量取决于公司的规模大小，考虑到本公司的规模不大，员工数量少，所以可以采取一次拉取所有数据的方案。

**数据更新策略**

要完成数据消费方的数据与数据生产方的数据同步，需要实现以下两点：寻找生产方和消费方数据的差集并消除双方的差异（生产方没有的数据，消费方需要删除；生产方有而消费方没有的数据，消费方需要新增）；生产方和消费方都有的数据，需要比对更新。

对于消除生产方与消费方的差集来说，消费方要确认哪些数据是生产方没有的，需要遍历消费方和生产方数据库，而消费方要确认哪些数据是生产方有但是消费方没有的，同样也需要遍历消费方和生产方数据库。显然，这样的遍历策略会导致同步的时间复杂度太高。因此需要采取改进的策略，可以给消费方的数据库待同步数据增加一个字段 latest_sync ，标识该数据是否是最新的。每次同步数据前，将表中的 latest_sync 字段置为0，表示数据都没更新，然后拉取并遍历生产方的数据，逐个查找消费方的数据库，是否存在数据，如果不存在，说明该数据需要在消费方新增，并置 lastest_sync 字段为1，如果存在，则比对更新，也置 lastest_sync 字段为1，如此遍历完成后，所有 lastest_sync 字段为0的数据就都是生产方没有但消费方有的数据，需要删除。对于数据的对比更新，通常这部分的业务逻辑更改的可能性较大，因为一旦生产方的数据结构发生改变，消费方的数据对比逻辑就会改变。所以这个模块可以做得相对灵活一些。
